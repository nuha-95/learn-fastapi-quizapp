name: QuizApp CI - Core Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install fastapi uvicorn sqlalchemy psycopg2-binary pydantic requests pytest

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Install Newman
      run: npm install -g newman newman-reporter-htmlextra

    - name: Create simple SQLite version
      run: |
        cat > main_ci.py << 'EOF'
        from fastapi import FastAPI, HTTPException
        from pydantic import BaseModel
        from typing import List
        import sqlite3
        import json

        app = FastAPI()

        # Simple in-memory storage for CI
        questions_db = []
        choices_db = []
        next_id = 1

        class ChoiceBase(BaseModel):
            choice_text: str
            is_correct: bool

        class QuestionBase(BaseModel):
            question_text: str
            choises: List[ChoiceBase]

        @app.get("/health")
        async def health_check():
            return {"status": "healthy", "message": "QuizApp API is running"}

        @app.get("/questions/")
        async def get_all_questions():
            return questions_db

        @app.post("/questions/")
        async def create_questions(question: QuestionBase):
            global next_id
            question_data = {"id": next_id, "question_text": question.question_text}
            questions_db.append(question_data)
            
            for choice in question.choises:
                choice_data = {
                    "id": len(choices_db) + 1,
                    "choice_text": choice.choice_text,
                    "is_correct": choice.is_correct,
                    "question_id": next_id
                }
                choices_db.append(choice_data)
            
            result = {"id": next_id, "message": "Question created successfully"}
            next_id += 1
            return result

        @app.get("/questions/{question_id}")
        async def read_question(question_id: int):
            for q in questions_db:
                if q["id"] == question_id:
                    return q
            raise HTTPException(status_code=404, detail='Question is not found.')

        @app.put("/questions/{question_id}")
        async def update_question(question_id: int, question: QuestionBase):
            for q in questions_db:
                if q["id"] == question_id:
                    q["question_text"] = question.question_text
                    # Remove old choices
                    global choices_db
                    choices_db = [c for c in choices_db if c["question_id"] != question_id]
                    # Add new choices
                    for choice in question.choises:
                        choice_data = {
                            "id": len(choices_db) + 1,
                            "choice_text": choice.choice_text,
                            "is_correct": choice.is_correct,
                            "question_id": question_id
                        }
                        choices_db.append(choice_data)
                    return {"message": "Question updated successfully"}
            raise HTTPException(status_code=404, detail='Question not found.')

        @app.delete("/questions/{question_id}")
        async def delete_question(question_id: int):
            global questions_db, choices_db
            questions_db = [q for q in questions_db if q["id"] != question_id]
            choices_db = [c for c in choices_db if c["question_id"] != question_id]
            return {"message": "Question deleted successfully"}

        @app.get("/choices/{question_id}")
        async def read_choices(question_id: int):
            result = [c for c in choices_db if c["question_id"] == question_id]
            if not result:
                raise HTTPException(status_code=404, detail='Choices not found.')
            return result

        @app.get("/stats")
        async def get_stats():
            total_questions = len(questions_db)
            total_choices = len(choices_db)
            return {
                "total_questions": total_questions,
                "total_choices": total_choices,
                "avg_choices_per_question": round(total_choices / total_questions, 2) if total_questions > 0 else 0
            }
        EOF

    - name: Create reports directory
      run: mkdir -p reports

    - name: Start FastAPI app
      run: |
        uvicorn main_ci:app --host 0.0.0.0 --port 8000 &
        sleep 5

    - name: Wait for API
      run: |
        for i in {1..10}; do
          if curl -f http://localhost:8000/health; then
            echo "API ready"
            break
          fi
          sleep 2
        done

    - name: Run Postman Tests
      run: |
        newman run tests/api/postman/QuizApp_Collection.json \
          -e tests/api/postman/QuizApp_Environment.json \
          -r htmlextra \
          --reporter-htmlextra-export reports/postman-report.html

    - name: Upload Reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-reports
        path: reports/